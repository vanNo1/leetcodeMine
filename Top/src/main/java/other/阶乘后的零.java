package other;

/**
 *
 * 给定一个整数 n，返回 n! 结果尾数中零的数量。
 *
 * 示例 1:
 *
 * 输入: 3
 * 输出: 0
 * 解释: 3! = 6, 尾数中没有零。
 * 示例 2:
 *
 * 输入: 5
 * 输出: 1
 * 解释: 5! = 120, 尾数中有 1 个零.
 * 说明: 你算法的时间复杂度应为 O(log n) 。
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 *
 * 思路：
 *   首先题目的意思是末尾有几个0
 *     比如6! = 【1* 2* 3* 4* 5* 6】
 *     其中只有2*5末尾才有0，所以就可以抛去其他数据 专门看2 5 以及其倍数 毕竟 4 * 25末尾也是0
 *     比如10！ = 【2*4*5*6*8*10】
 *     其中 4能拆成2*2  10能拆成2*5
 *     所以10！ = 【2*（2*2）*5*（2*3）*（2*2*2）*（2*5）】
 *     一个2和一个5配对 就产生一个0 所以10！末尾2个0
 *
 *     转头一想 2肯定比5多 所以只数5的个数就行了
 *
 *     假若N=31 31里能凑10的5为[5, 2*5, 3*5, 4*5, 25, 6*5] 其中 25还能拆为 5**2
 *     所以 里面的5的个数为 int(31/(5**1)) +  int(31/(5**2))
 *     所以 只要先找个一个 5**x < n 的x的最大数 然后按上面循环加起来
 *
 *     就比如n=200
 *     第一次/5 等于 40。 相当于有1*5，2*5，... , 40*5。这一波，右边就有40个5
 *     而1-40 中又有：40/5 等于8。相当于 1*5，2*5， ... , 8*5。这一波右边有8个5
 *     而1-8 中又有：8/5 等于 1 。相当于有 1*5 .这一波右边有1个5.
 *     总的来说有40+8+1 个 5 。
 */
public class 阶乘后的零 {
    public int trailingZeroes(int n) {
        int count = 0;
        while(n >= 5) {
            count += n / 5;
            n /= 5;
        }
        return count;
    }
}
